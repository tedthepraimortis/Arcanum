class HDArcanumTome : HDWeapon
{
	enum ArcanumTomeFlags
	{
		ATF_InSpellMenu = 1 << 0
	}

	enum ArcanumTomeProperties
	{
		ATProp_Flags,
		ATProp_SelectedTree,
		ATProp_SelectedSpell
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner , bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override double GunMass() { return 4; }
	override double WeaponBulk() { return 20; }
	override string, double GetPickupSprite() { return "ARCTZ0", 1.0; }
	override string GetHelpText()
	{
		string HText = WEPHELP_FIRE.."  Place rune\n"
		..WEPHELP_ALTFIRE.."  Create spell circle\n"
		..WEPHELP_ZOOM.."  Spell manager";

		if (WeaponStatus[ATProp_Flags] & ATF_InSpellMenu)
		{
			HText = WEPHELP_FIRE.." or "..WEPHELP_ALTFIRE.."  Cycle spells\n"
			..WEPHELP_FIREMODE.."+"..WEPHELP_FIRE.." or "..WEPHELP_ALTFIRE.."  Cycle spell trees\n"
			..WEPHELP_ZOOM.."  Exit spell manager";
		}

		return HText;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		ArcanumSpell selSpell = GetSelectedSpell();
		selSpell.DrawHUDStuff(sb, hpl);

		if (!(hdw.WeaponStatus[ATProp_Flags] & ATF_InSpellMenu))
		{
			return;
		}

		Font fnt = "SPTTLFNT";
		HUDFont TitleFont = HUDFont.Create(fnt);

		fnt = "SPDSCFNT";
		HUDFont DescFont = HUDFont.Create(fnt);

		int BaseOffset = -100;

		int SelTreeIndex = hdw.WeaponStatus[ATProp_SelectedTree];
		ArcanumSpellTree SelTree = SpellStorage.Trees[SelTreeIndex];
		sb.DrawString(TitleFont, SelTree.GetName(), (-140, BaseOffset), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT);
		sb.DrawString(DescFont, SelTree.GetDescription(), (-140, BaseOffset + 20), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE, 1.0, 280, 1);

		sb.DrawString(TitleFont, "Spells", (-140, BaseOffset + 90), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT);
		for (int i = 0; i < SelTree.Spells.Size(); ++i)
		{
			ArcanumSpell CurSpell = SelTree.Spells[i];
			sb.DrawString(DescFont, CurSpell.GetName(), (-140, BaseOffset + 110 + 10 * i), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, CurSpell == SelSpell ? Font.CR_GOLD : Font.CR_WHITE);
		}
		
		int yOff = BaseOffset + 90;
		sb.DrawString(TitleFont, selSpell.GetName(), (-40, yOff), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_TEAL);
		if (selSpell.GetMaxLevel() > 1)
		{
			string RomanNumeral = "";
			switch (selSpell.Level)
			{
				case 1: RomanNumeral = "I"; break;
				case 2: RomanNumeral = "II"; break;
				case 3: RomanNumeral = "III"; break;
				case 4: RomanNumeral = "IV"; break;
				case 5: RomanNumeral = "V"; break;
			}

			string FullString = "\c[Gold]Level "..RomanNumeral.."\c-";
			if (selSpell.Level < selSpell.GetMaxLevel())
			{
				FullString = FullString.." [";
				for (int i = 0; i <= 10; ++i)
				{
					int Percentage = int(floor((selSpell.Experience / double(selSpell.ExperienceReqs[selSpell.Level - 1])) * 10));
					FullString = FullString..(i < Percentage ? "=" : " ");
				}
				FullString = FullString.."]";
			}
			sb.DrawString(DescFont, FullString, (-40, yOff + 20), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE);
			yOff += 10;
		}
		
		sb.DrawString(DescFont, selSpell.GetTechnicalInfo(), (-40, yOff + 20), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_OLIVE);

		double mult = AceCore.CheckForItem(hpl, "HDSoulCube") ? 0.80 : 1.0;
		int cost, blues;
		[cost, blues] = selSpell.GetCastRequirements();
		cost = int(cost * mult);
		blues = int(blues * mult);

		string str = String.Format("\c[Red]%i\c-", cost);
		if (blues > 0)
		{
			str = str..String.Format("\c[DarkGray]/\c[ArcanumReqBlue]%i\c-", blues);
		}
		sb.DrawString(DescFont, "\c[DarkGray]Cost: "..str, (-40, yOff + 30), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT);
		sb.DrawString(DescFont, selSpell.GetDescription(), (-40, yOff + 50), sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT, Font.CR_WHITE, 1.0, 180, 1);
	}

	override void DrawSightPicture(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl, bool sightbob, vector2 bob, double fov, bool scopeview, actor hpc, string whichdot)
	{
		int cx, cy, cw, ch;
		[cx, cy, cw, ch] = Screen.GetClipRect();
		sb.SetClipRect(-16 + bob.x, -16 + bob.y, 32, 32, sb.DI_SCREEN_CENTER);
		vector2 bob2 = bob * 2;
		bob2.y = clamp(bob2.y, -8, 8);
		sb.DrawImage("ARCNFRNT", (0, -2) + bob2, sb.DI_SCREEN_CENTER | sb.DI_ITEM_TOP, alpha: 0.9);
		sb.SetClipRect(cx, cy, cw, ch);
	}

	override void DetachFromOwner()
	{
		WeaponStatus[ATProp_Flags] &= ~ATF_InSpellMenu;

		Super.DetachFromOwner();
	}

	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);
		InitStorage();
	}

	private void InitStorage()
	{
		SpellStorage = ArcanumSpellBrain.Get(owner.PlayerNumber());
	}

	private clearscope ArcanumSpellTree GetSelectedTree()
	{
		return SpellStorage.Trees[WeaponStatus[ATProp_SelectedTree]];
	}

	private clearscope ArcanumSpell GetSelectedSpell()
	{
		return GetSelectedTree().Spells[WeaponStatus[ATProp_SelectedSpell]];
	}

	private action void A_NextTree()
	{
		int TreeCount = invoker.SpellStorage.Trees.Size();
		invoker.WeaponStatus[ATProp_SelectedSpell] = 0;
		if (++invoker.WeaponStatus[ATProp_SelectedTree] >= TreeCount)
		{
			invoker.WeaponStatus[ATProp_SelectedTree] = 0;
		}
	}

	private action void A_PrevTree()
	{
		int TreeCount = invoker.SpellStorage.Trees.Size();
		invoker.WeaponStatus[ATProp_SelectedSpell] = 0;
		if (--invoker.WeaponStatus[ATProp_SelectedTree] < 0)
		{
			invoker.WeaponStatus[ATProp_SelectedTree] = TreeCount - 1;
		}
	}

	private action void A_NextSpell()
	{
		int SpellCount = invoker.SpellStorage.SpellCountInTree(invoker.SpellStorage.Trees[invoker.WeaponStatus[ATProp_SelectedTree]].GetClass());
		invoker.WeaponStatus[ATProp_SelectedSpell]++;
		if (invoker.WeaponStatus[ATProp_SelectedSpell] >= SpellCount)
		{
			invoker.WeaponStatus[ATProp_SelectedSpell] = 0;
		}
	}

	private action void A_PrevSpell()
	{
		int SpellCount = invoker.SpellStorage.SpellCountInTree(invoker.SpellStorage.Trees[invoker.WeaponStatus[ATProp_SelectedTree]].GetClass());
		invoker.WeaponStatus[ATProp_SelectedSpell]--;
		if (invoker.WeaponStatus[ATProp_SelectedSpell] < 0)
		{
			invoker.WeaponStatus[ATProp_SelectedSpell] = SpellCount - 1;
		}
	}

	override void ActualPickup(Actor other, bool silent)
	{
		let Tome = HDArcanumTome(other.FindInventory("HDArcanumTome"));
		if (Tome && Tome.SpellStorage)
		{
			// [Ace] Only give experience to spells that fit the bill, i.e. those that actually support experience.
			Array<ArcanumSpell> valid;
			for (int i = 0; i < Tome.SpellStorage.Trees.Size(); ++i)
			{
				for (int j = 0; j < Tome.SpellStorage.Trees[i].Spells.Size(); ++j)
				{
					let cur = Tome.SpellStorage.Trees[i].Spells[j];
					if (cur.Level < cur.GetMaxLevel())
					{
						valid.Push(cur);
					}
				}
			}

			int VSize = valid.Size();
			for (int i = 0; VSize > 0 && i < 25; ++i)
			{
				let cur = valid[random(0, VSize - 1)];
				if (cur.GainExperience())
				{
					other.A_Log(cur.GetName().." has gained a level.", true);
				}
			}

			other.A_StartSound("weapons/pocket");
			other.A_Log("Your knowledge grows.", true);
			Destroy();
			return;
		}
		
		Super.ActualPickup(other, silent);
	}

	ArcanumSpellBrain SpellStorage;
	private transient CVar InvertSelection;
	private transient CVar ZoomHold;

	Default
	{
		+HDWEAPON.FITSINBACKPACK
		+INVENTORY.INVBAR
		HDWeapon.BarrelSize 5, 2, 1; // [Ace] I don't even know why.
		Scale 0.6;
		Tag "Arcanum tome";
		Inventory.PickupSound "weapons/pocket";
		HDWeapon.Refid "arc";
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "You picked up the Arcanum tome of knowledge. Unlimited power awaits those with the energy within.";
	}

	States
	{
		Spawn:
			ARCT Z -1;
			Stop;
		ReadyBook:
			ARCB A 1;
			Loop;
		Ready:
			ARCT A 1
			{
				if (!invoker.ZoomHold)
				{
					invoker.ZoomHold = CVar.GetCVar('arcanum_zoomhold', player);
				}
				if (invoker.ZoomHold.GetBool())
				{
					if (PressingZoom() && !(invoker.WeaponStatus[ATProp_Flags] & ATF_InSpellMenu))
					{
						invoker.WeaponStatus[ATProp_Flags] |= ATF_InSpellMenu;
						A_SetHelpText();
					}
					if (!PressingZoom() && invoker.WeaponStatus[ATProp_Flags] & ATF_InSpellMenu)
					{
						invoker.WeaponStatus[ATProp_Flags] &= ~ATF_InSpellMenu;
						A_SetHelpText();
					}
				}
				else if (JustPressed(BT_ZOOM))
				{
					if (invoker.WeaponStatus[ATProp_Flags] & ATF_InSpellMenu)
					{
						invoker.WeaponStatus[ATProp_Flags] &= ~ATF_InSpellMenu;
						A_SetHelpText();
					}
					else
					{
						invoker.WeaponStatus[ATProp_Flags] |= ATF_InSpellMenu;
						A_SetHelpText();
					}
					SetWeaponState("Nope");
					return;
				}

				if (invoker.WeaponStatus[ATProp_Flags] & ATF_InSpellMenu)
				{
					if (!invoker.InvertSelection)
					{
						invoker.InvertSelection = CVar.GetCVar('arcanum_invert', player);
					}

					int InvertFlags = invoker.InvertSelection.GetInt();
					if (JustPressed(BT_ATTACK))
					{
						if (PressingFiremode())
						{
							if (InvertFlags & 1)
							{
								A_PrevTree();
							}
							else
							{
								A_NextTree();
							}
						}
						else if (InvertFlags & 2)
						{
							A_PrevSpell();
						}
						else
						{
							A_NextSpell();
						}
					}
					else if (JustPressed(BT_ALTATTACK))
					{
						if (PressingFiremode())
						{
							if (InvertFlags & 1)
							{
								A_NextTree();
							}
							else
							{
								A_PrevTree();
							}
						}
						else if (InvertFlags & 2)
						{
							A_NextSpell();
						}
						else
						{
							A_PrevSpell();
						}
					}
					A_WeaponReady(WRF_NOFIRE);
					return;
				}
				A_WeaponReady(WRF_ALL);
			}
			Goto ReadyEnd;
		Select0:
			ARCT A 0 A_Overlay(10, 'ReadyBook');
			Goto Select0Small;
		Deselect0:
			ARCT A 0
			{
				invoker.WeaponStatus[ATProp_Flags] &= ~ATF_InSpellMenu;
			}
			Goto Deselect0Small;
		DeadLowered:
			ARTC A -1 A_ClearOverlays(10, 10);
			Stop;
		User3:
			ARCT A 0 A_SelectWeapon("PickupManager");
			Goto Ready;
		Fire:
			ARCT E 5
			{
				player.GetPSPrite(PSP_WEAPON).frame = random(1, 3);
				FLineTraceData Data;
				for (int i = 8; i <= 192; i += 8)
				{
					LineTrace(angle, i, pitch, TRF_NOSKY | TRF_ALLACTORS, height - 6, 0, 0, Data);
					if (Data.HitType == Data.TRACE_HitActor && Data.HitActor is 'ArcanumRuneSlot')
					{
						let RuneSlot = ArcanumRuneSlot(Data.HitActor);
						let Sigil = ArcanumSigil(RuneSlot.master);

						if (Sigil && Sigil.master == self)
						{
							RuneSlot.ActivateRune(self);
						}
						break;
					}
				}
			}
			ARCT A 2;
			Goto Nope;
		AltFire:
			ARCT A 1;
			ARCT A 0
			{
				ArcanumSpell SelSpell = invoker.GetSelectedSpell();
				int ST = SelSpell.GetSpellType();

				double MPitch = min(ArcanumSigil.SelfCastMaxPitch, player.MaxPitch - (90 - ArcanumSigil.SelfCastMaxPitch));
				if (ST & ArcanumSpell.SType_SelfOrMass && !(ST & ArcanumSpell.SType_Targeted) && pitch < MPitch)
				{
					A_SetPitch(pitch + 10, SPF_INTERPOLATE);
					A_Refire('AltFire');
					return;
				}

				if (ST & ArcanumSpell.SType_SelfOrMass && pitch >= MPitch || ST & ArcanumSpell.SType_Targeted)
				{
					SetWeaponState('ActuallyAltFire');
					return;
				}
			}
			Goto Nope;
		ActuallyAltFire:
			ARCT E 5
			{
				ArcanumSpell selSpell = invoker.GetSelectedSpell();

				let plr = HDPlayerPawn(self);

				double mult = AceCore.CheckForItem(plr, "HDSoulCube") ? 0.80 : 1.0;
				int cost, blues;
				[cost, blues] = selSpell.GetCastRequirements();
				cost = int(cost * mult);
				blues = int(blues * mult);

				if (CountInv('HDBlues') >= blues)
				{
					FLineTraceData Data;
					LineTrace(angle, radius + 10, pitch, TRF_NOSKY, height - 6, 0, 0, Data);
					if (Data.HitType == Data.TRACE_HitNone || Data.HitType == Data.TRACE_HitFloor)
					{
						if (selSpell.GainExperience())
						{
							A_Log(selSpell.GetName().." has gained a level.", true);
						}
						
						plr.bloodloss += cost;
						if (blues > 0)
						{
							A_TakeInventory('HDBlues', blues);
						}

						ArcanumSigil c = ArcanumSigil(Spawn(selSpell.GetSigil(), Data.HitLocation));
						c.angle = angle;
						if (!c.bDONTPITCH)
						{
							c.pitch = pitch;
						}
						c.master = self;
						c.SigilLevel = selSpell.Level;

						double MPitch = min(ArcanumSigil.SelfCastMaxPitch, player.MaxPitch - (90 - ArcanumSigil.SelfCastMaxPitch));
						int SpellType = selSpell.GetSpellType();
						if (SpellType & ArcanumSpell.SType_SelfOrMass && pitch >= MPitch)
						{
							c.SigilType = ArcanumSpell.SType_SelfOrMass;
						}
						else
						{
							c.SigilType = ArcanumSpell.SType_Targeted;
						}
					}
				}
				else
				{
					A_WeaponMessage("You don't feel powerful enough to cast "..selSpell.GetName()..".");
				}
			}
			ARCT A 2;
			Goto Nope;
	}
}