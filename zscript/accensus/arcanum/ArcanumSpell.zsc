class ArcanumSpellTree abstract play
{
	abstract clearscope string GetName() const;
	abstract clearscope string GetDescription() const;
	Array<ArcanumSpell> Spells;

	void InsertSpell(ArcanumSpell spl)
	{
		int InsIndex = 0;
		int SpellsCount = Spells.Size();
		if (SpellsCount > 0)
		{
			for (int i = 0; i < SpellsCount; ++i)
			{
				if (spl.GetIndex() >= Spells[i].GetIndex())
				{
					InsIndex = i + 1;
				}
				else
				{
					InsIndex = i;
					break;
				}
			}
		}
		Spells.Insert(InsIndex, spl);
	}

	bool SpellExists(class<ArcanumSpell> spell)
	{
		for (int i = 0; i < Spells.Size(); ++i)
		{
			if (Spells[i].GetClass() == spell)
			{
				return true;
			}
		}

		return false;
	}
}

class ArcanumTreeDestruction : ArcanumSpellTree
{
	override string GetName() { return Stringtable.Localize("$ARCANUM_TREE_DESTRUCTION"); }
	override string GetDescription() { return Stringtable.Localize("$ARCANUM_TREE_DESTRUCTION_DESC"); }
}

class ArcanumTreeRestoration : ArcanumSpellTree
{
	override string GetName() { return Stringtable.Localize("$ARCANUM_TREE_RESTORATION"); }
	override string GetDescription() { return Stringtable.Localize("$ARCANUM_TREE_RESTORATION_DESC"); }
}

class ArcanumTreeAlteration : ArcanumSpellTree
{
	override string GetName() { return Stringtable.Localize("$ARCANUM_TREE_ALTERATION"); }
	override string GetDescription() { return Stringtable.Localize("$ARCANUM_TREE_ALTERATION_DESC"); }
}

class ArcanumTreeConjuration : ArcanumSpellTree
{
	override string GetName() { return Stringtable.Localize("$ARCANUM_TREE_CONJURATION"); }
	override string GetDescription() { return Stringtable.Localize("$ARCANUM_TREE_CONJURATION_DESC"); }
}

class ArcanumSpell abstract play
{
	enum SType
	{
		SType_SelfOrMass = 1,
		SType_Targeted = 2
	}

	abstract class<ArcanumSpellTree> GetTree() const;
	abstract int GetIndex() const;
	abstract string GetName() const;
	abstract int GetSpellType() const;
	abstract int GetManaCost() const; // [Ace] Returns: blood, blues.
	abstract ui string GetDescription() const;
	abstract ui string GetTechnicalInfo() const;
	abstract int GetMaxExperience() const;
	abstract class<ArcanumSigil> GetSigil() const;	
	virtual ui void DrawHudStuff(HDStatusBar sb, HDPlayerPawn hpl, HDArcanumTome tome) { }
	
	// Made to make localization much easier. Taken from Lithium. - [tedthepraimortis]
	static clearScope string loc(string nm) { 
		if(nm.charat(0)=="$"){
			nm = nm.mid(1);
		}
		string rtrn=StringTable.localize(nm, false);
		return rtrn!=nm?rtrn:""..rtrn.." doesn't exist! try inputting it into the language lump or checking your spelling!";
	}

	// [Ace; 17.01.22] This is currently unused because I've opted for a threshold system rather than a time duration.
	// HDest is a slow mod so half the time the effects expire before you've made use of them or they require you to know in advance that you'd need them.
	// This virtual only makes sense for timed effects whose indicator is not drawn in DrawHudStuff.
	// The returns are the graphic to use and the class the internal stuff should check for.
	virtual ui string, class<Powerup> GetIndicatorInfo() const { return "", null; }

	// [Ace] Returns whether or not the spell reached max level.
	bool GainExperience(double amt)
	{
		int maxExp = GetMaxExperience();
		if (Experience == maxExp)
		{
			return false;
		}

		Experience = min(maxExp, Experience + amt);
		return Experience == maxExp;
	}

	clearscope double GetExperienceFactor()
	{
		int maxExp = GetMaxExperience();
		return maxExp > 0 ? Experience / maxExp : 0;
	}

	double Experience;
}

class ArcanumIndicator ui
{
	string Icon;
	Vector2 Pos;
	Color Col;
}